import os
import asyncio
import traceback
from html import escape
from pprint import pprint
import yaml

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.enums import ParseMode
from rag_processor import *
from dotenv import load_dotenv
from gigachat import GigaChat
from gigachat.models import Chat, Messages, MessagesRole
from pydantic import BaseModel, Field, ValidationError

class GCProcessor(RAG):
    def __init__(self, gigachat_model: str = "GigaChat"):
        super().__init__()
        self.api_key = os.environ.get("GIGACHAT_API_KEY", None)
        self.giga_chat = GigaChat(credentials=self.api_key, verify_ssl_certs=False)
        self.user = MessagesRole.USER
        self.system = MessagesRole.SYSTEM
        self.gigachat_model = gigachat_model

    @property
    def gigachat_model(self):
        return self._gigachat_model

    @gigachat_model.setter
    def gigachat_model(self, value):
        self._gigachat_model = value

    def get_answer(self, user: str, system_prompt: str = "", temperature: float = 0.0):
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ GigaChat –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç."""
        messages = [
            Messages(role=self.system, content=system_prompt),
            Messages(role=self.user, content=user)
        ]

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç –æ—Ç GigaChat
        response = self.giga_chat.chat(Chat(messages=messages, temperature=temperature, model=self.gigachat_model))
        return response.choices[0].message.content

class Config:
    os.environ.clear()
    load_dotenv(".venv/.env")
    FAISS_ROOT = os.path.join(os.getcwd(), "DB_FAISS")
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    DEFAULT_K = 4

# –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ñ–∞–π–ª–∞
class PromptsSchema(BaseModel):
    system_prompt: str
    user_template: str
    generation_settings: dict = Field(
        default={"temperature": 0.0, "model_name": "GigaChat"},
        description="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤"
    )

class PromptManager:
    def __init__(self, file_path: str = "prompts.yaml"):
        self.file_path = file_path  # –•—Ä–∞–Ω–∏–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
        self._load_prompts()
        self.last_modified = 0

    def _load_prompts(self):
        with open(self.file_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)

        try:
            # –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ñ–∞–π–ª–∞
            validated = PromptsSchema(**data)
            self.system = validated.system_prompt
            self.user_template = validated.user_template
            self.temperature = validated.generation_settings.get("temperature", 0.0)
            self.model_name = validated.generation_settings.get("model_name", "GigaChat")
            self.last_modified = os.path.getmtime(self.file_path)

        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–º–ø—Ç–æ–≤: {e}")
            # –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            self.system = "–¢—ã - –±–æ–ª—å—à–∞—è —è–∑—ã–∫–æ–≤–∞—è –º–æ–¥–µ–ª—å. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ - –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –æ–ø–∏—Ä–∞—è—Å—å –Ω–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã"
            self.user_template = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–¥–∞–ª –≤–æ–ø—Ä–æ—Å: {question}. –û—Ç–≤–µ—Ç—å –Ω–∞ –Ω–µ–≥–æ, –ø–æ–ª—å–∑—É—è—Å—å —Å–ª–µ–¥—É—é—â–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏: {doci}"
            self.temperature = 0.0
            self.model_name = "GigaChat"


    def get_prompts(self):
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
        current_modified = os.path.getmtime(self.file_path)  # –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–∞—Ç—É –∏–∑–º–µ–Ω–µ–Ω–∏—è
        if current_modified > self.last_modified:  # –ï—Å–ª–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            self._load_prompts()  # –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–æ–º–ø—Ç—ã, —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É, –º–æ–¥–µ–ª—å_name –∏ –¥—Ä—É–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        return { # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
            "system": self.system,
            "user_template": self.user_template,
            "temperature": self.temperature,
            "model_name": self.model_name
        }

# config = Config()
bot = Bot(token=Config.BOT_TOKEN)
dp = Dispatcher()
processor = DBConstructor()
user_sessions = {}
prompt_manager = PromptManager()  # –ß–∏—Ç–∞–µ—Ç prompts.yaml –≤ –ø–µ—Ä–≤—ã–π —Ä–∞–∑
answer_generator = GCProcessor(prompt_manager.get_prompts()["model_name"])  # –ë–µ—Ä—ë—Ç –º–æ–¥–µ–ª—å –∏–∑ —Ñ–∞–π–ª–∞

# ====================== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ======================
async def on_startup(bot: Bot):
    print("üîÑ –ó–∞–ø—É—Å–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤...")

    try:
        set_embs_result = processor.set_embeddings(Config.FAISS_ROOT, verbose=False)
        processor.db_metadata = set_embs_result["result"]["metadata"]
        pprint(processor.db_metadata)

        if not set_embs_result["success"]:
            error_msg = set_embs_result.get("result", {}).get("Error", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
            print(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {error_msg}")
            return

        print("‚úÖ –≠–º–±–µ–¥–¥–∏–Ω–≥–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")


    except Exception as e:
        print(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ: {str(e)}")
        raise
# ====================== –ö–æ–º–∞–Ω–¥—ã ===========================
# --------------------- –ö–æ–º–∞–Ω–¥–∞ /start ---------------------
@dp.message(Command("start"))
async def start(message: types.Message):
    try:
        categories = [
            d for d in os.listdir(Config.FAISS_ROOT)
            if os.path.isdir(os.path.join(Config.FAISS_ROOT, d))
        ]

        if not categories:
            await message.answer("‚ö†Ô∏è –ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!")
            return

        keyboard = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [types.InlineKeyboardButton(
                    text=category,
                    callback_data=f"category_{category}"
                )]
                for category in categories
            ]
        )

        await message.answer("üìÇ –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤:", reply_markup=keyboard)

    except Exception as e:
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π")
        print(f"‚ùó –û—à–∏–±–∫–∞ –≤ /start: {e}")

# -------------- –ö–æ–º–∞–Ω–¥–∞ /getsystem –ó–∞–ø—Ä–æ—Å —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ --------------
# –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π Dispatcher
@dp.message(Command("getsystem"))
async def cmd_get_system(message: types.Message):
    prompts = prompt_manager.get_prompts()
    await message.answer(
        "üìù <b>–¢–µ–∫—É—â–∏–π —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç:</b>\n\n"
        f"<code>{escape(prompts['system'])}</code>",
        parse_mode=ParseMode.HTML
    )

# ---------------- –ö–æ–º–∞–Ω–¥–∞ /getuserprompt –ó–∞–ø—Ä–æ—Å user-–ø—Ä–æ–º–ø—Ç–∞ ----------------
@dp.message(Command("getuserprompt"))
async def cmd_get_user_prompt(message: types.Message):
    prompts = prompt_manager.get_prompts()
    await message.answer(
        "üìã <b>–¢–µ–∫—É—â–∏–π user template:</b>\n\n"
        f"<code>{escape(prompts['user_template'])}</code>",
        parse_mode=ParseMode.HTML
    )

# -------------- –ö–æ–º–∞–Ω–¥–∞ /getsettings –ó–∞–ø—Ä–æ—Å —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —É—Å—Ç–∞–Ω–æ–≤–æ–∫ --------------
@dp.message(Command("getsettings"))
async def cmd_get_settings(message: types.Message):
    prompts = prompt_manager.get_prompts()
    await message.answer(
        "‚öôÔ∏è <b>–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b>\n\n"
        f"üß† –ú–æ–¥–µ–ª—å: <code>{escape(answer_generator.gigachat_model)}</code>\n"
        f"üå° –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: <code>{prompts['temperature']}</code>",
        parse_mode=ParseMode.HTML
    )

# ================================ –õ–æ–≥–∏–∫–∞ –±–æ—Ç–∞ ================================
# ----------------------- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ ----------------------
@dp.callback_query(F.data.startswith("category_"))
async def handle_category(callback: types.CallbackQuery):
    try:
        user_id = callback.from_user.id
        category = callback.data.split("_", 1)[1]  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏
        user_sessions[user_id] = {
            "faiss_indexes": [],  # –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ
            "query_prefix": "",
            "last_results": []  # –í–∞–∂–Ω–æ: —Å–æ–∑–¥–∞–µ–º –∫–ª—é—á –∑–∞—Ä–∞–Ω–µ–µ
        }

        # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø—É—Ç—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        category_path = os.path.join(Config.FAISS_ROOT, category)
        if not os.path.exists(category_path):
            await callback.answer("‚ùå –ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
            return

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å "–ó–∞–≥—Ä—É–∑–∫–∞..."
        await callback.answer("‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...")

        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –±–∞–∑
        faiss_indexes = []
        faiss_paths = [d for d, _, files in os.walk(category_path) for file in files if file.endswith(".faiss")]

        print(faiss_paths)

        # –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
        progress_msg = await callback.message.answer("üîÑ –ü—Ä–æ–≥—Ä–µ—Å—Å: 0%")

        for idx, faiss_dir in enumerate(faiss_paths):
            # –ó–∞–≥—Ä—É–∑–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            load_result = await asyncio.to_thread(
                processor.faiss_loader,
                faiss_dir,
                hybrid_mode=False
            )

            if load_result["success"]:
                faiss_indexes.append(load_result["db"])

            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            progress = (idx + 1) / len(faiss_paths) * 100
            await progress_msg.edit_text(f"üîÑ –ü—Ä–æ–≥—Ä–µ—Å—Å: {int(progress)}%")

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        user_sessions[user_id] = {
            "faiss_indexes": faiss_indexes,
            "query_prefix": "query: " if processor.db_metadata.get("is_e5_model", False) else ""
        }

        user_sessions[user_id].update({
            "faiss_indexes": faiss_indexes,
            "query_prefix": "query: " if processor.db_metadata.get("is_e5_model", False) else ""
        })

        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
        await progress_msg.delete()
        await callback.message.answer(f"‚úÖ –ë–∞–∑–∞ '{category}' –≥–æ—Ç–æ–≤–∞ –∫ –ø–æ–∏—Å–∫—É!")

    except Exception as e:
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏", show_alert=True)
        print(f"‚ùó –û—à–∏–±–∫–∞: {str(e)}")
        traceback.print_exc()
# --------------------- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ ---------------------
@dp.message(F.text)
async def handle_query(message: types.Message):
    try:
        user_id = message.from_user.id
        if user_id not in user_sessions:
            await message.answer("‚ùå –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —á–µ—Ä–µ–∑ /start")
            return

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–∏—Å–∫–∞
        search_msg = await message.answer("‚è≥ –ò—â—É –æ—Ç–≤–µ—Ç –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö...")

        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        session = user_sessions[user_id]

        # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫
        raw_results = await processor.multi_async_search(
            query=session["query_prefix"] + message.text,
            indexes=session["faiss_indexes"],
            search_function=processor.aformatted_scored_sim_search_by_cos,
            k=Config.DEFAULT_K
        )

        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —á–∞–Ω–∫–æ–≤
        sorted_results = sorted(
            raw_results,
            key=lambda x: x["score"],
            reverse=True
        )[:3]  # –¢–æ–ø-3 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

        # –°–æ–±–∏—Ä–∞–µ–º –ø–æ–ª–Ω—ã–µ —Å—Ç–∞—Ç—å–∏ –¥–ª—è –≤—Å–µ—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        session["articles"] = []
        for result in sorted_results:
            full_content = await assemble_full_content(
                main_chunk=result,
                faiss_indexes=session["faiss_indexes"]
            )
            session["articles"].append({
                "title": result["metadata"].get("_title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"),
                "content": full_content,
                "score": result["score"],
                "element_type": result["metadata"].get("element_type", "text")
            })

        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è –º–æ–¥–µ–ª–∏
        user_prompt = "\n\n".join(
            f"–°—Ç–∞—Ç—å—è {i + 1} ({art['score']:.0%}): {art['title']}\n{art['content'][:1500]}..."
            for i, art in enumerate(session["articles"])
        )

        prompts = prompt_manager.get_prompts()

        if answer_generator.gigachat_model != prompts["model_name"]:
            answer_generator.gigachat_model = prompts["model_name"]  # –ü—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –º–æ–¥–µ–ª–∏

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç —Å –ø–æ–º–æ—â—å—é GigaChat
        answer = answer_generator.get_answer(
            user=prompts["user_template"].format(question=message.text, doci=user_prompt),
            system_prompt=prompts["system"],
            temperature=prompts["temperature"]
        )

        # –£–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–∏—Å–∫–∞.
        await search_msg.delete()

        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
        builder = InlineKeyboardBuilder()
        for idx, art in enumerate(session["articles"]):
            builder.button(
                text=f"{art['title']} ({art['score']:.0%})",
                callback_data=f"show_article_{idx}"
            )
        builder.adjust(1)

        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        response = f"üîç {answer}\n\n" "üìö –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏:\n"

        await message.answer(response, reply_markup=builder.as_markup(), parse_mode=ParseMode.MARKDOWN)

    except Exception as e:
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞")
        print(f"ERROR: {str(e)}")
        traceback.print_exc()


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Å—Ç–∞—Ç—å–∏
@dp.callback_query(F.data.startswith("show_article_"))
async def handle_article_selection(callback: types.CallbackQuery):
    try:
        user_id = callback.from_user.id
        session = user_sessions.get(user_id)

        if not session or "articles" not in session:
            await callback.answer("‚ùå –°–µ—Å—Å–∏—è —É—Å—Ç–∞—Ä–µ–ª–∞. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫.")
            return

        article_idx = int(callback.data.split("_")[-1])
        article = session["articles"][article_idx]

        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
        header = (
            f"üìÑ –î–æ–∫—É–º–µ–Ω—Ç: {article['title']}\n"
            f"üîó –¢–∏–ø: {'—Ç–∞–±–ª–∏—Ü–∞' if article['element_type'] == 'table' else '—Ç–µ–∫—Å—Ç'}\n"
            f"üìè –¢–æ—á–Ω–æ—Å—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è: {article['score']:.0%}\n\n"
        )

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å —Ä–∞–∑–±–∏–≤–∫–æ–π
        await callback.message.answer(header)
        await send_long_message(callback.message, article["content"])
        await callback.answer()

    except Exception as e:
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç–∞—Ç—å–∏")
        print(f"CALLBACK ERROR: {str(e)}")
        traceback.print_exc()

async def assemble_full_content(main_chunk: dict, faiss_indexes: list) -> str:
    """–°–±–æ—Ä–∫–∞ –ø–æ–ª–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–∑ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —á–∞–Ω–∫–æ–≤"""
    chunks = []
    visited = set()
    queue = [main_chunk["metadata"]["chunk_id"]]

    while queue:
        chunk_id = queue.pop(0)
        if chunk_id in visited:
            continue

        # –ü–æ–∏—Å–∫ —á–∞–Ω–∫–∞ –≤–æ –≤—Å–µ—Ö –∏–Ω–¥–µ–∫—Å–∞—Ö
        chunk = None
        for index in faiss_indexes:
            chunk = next(
                (doc for doc in index.docstore._dict.values()
                 if doc.metadata["chunk_id"] == chunk_id),
                None
            )
            if chunk:
                break

        if chunk:
            chunks.append(chunk)
            visited.add(chunk_id)
            queue.extend(
                linked_id
                for linked_id in chunk.metadata.get("linked", [])
                if linked_id not in visited
            )

    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É chunk_id (–ø—Ä–∏–º–µ—Ä: doc1_p1, doc1_p2)
    chunks.sort(key=lambda x: x.metadata["chunk_id"])

    # –°–±–æ—Ä–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    return "\n\n".join(
        chunk.page_content.replace("passage:", "").strip()
        for chunk in chunks
    )

def format_response(main_chunk: dict, content: str) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞"""
    header = f"üìÑ –î–æ–∫—É–º–µ–Ω—Ç: {main_chunk['metadata'].get('_title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}\n"
    element_type = main_chunk["metadata"].get("element_type", "text")

    if element_type == "table":
        return f"{header}üìä –¢–∞–±–ª–∏—Ü–∞:\n{content}"

    if len(content) > 4000:
        content = content[:3900] + "\n[...—Ç–µ–∫—Å—Ç —Å–æ–∫—Ä–∞—â–µ–Ω...]"

    return f"{header}{content}"


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–ª–∏–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)
async def send_long_message(
        message: types.Message,
        text: str,
        max_length: int = 4000,
        delimiter: str = "\n\n"
) -> None:
    """–£–º–Ω–∞—è —Ä–∞–∑–±–∏–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞ —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"""
    parts = []
    current_part = []
    current_len = 0

    for paragraph in text.split(delimiter):
        para_len = len(paragraph)

        if current_len + para_len > max_length:
            if current_part:
                parts.append(delimiter.join(current_part))
                current_part = []
                current_len = 0

            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω—ã—Ö –∞–±–∑–∞—Ü–µ–≤
            while para_len > max_length:
                parts.append(paragraph[:max_length])
                paragraph = paragraph[max_length:]
                para_len = len(paragraph)

        if para_len > 0:
            current_part.append(paragraph)
            current_len += para_len + len(delimiter)

    if current_part:
        parts.append(delimiter.join(current_part))

    # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å –Ω—É–º–µ—Ä–∞—Ü–∏–µ–π
    total = len(parts)
    for i, part in enumerate(parts, 1):
        header = f"üìñ –ß–∞—Å—Ç—å {i}/{total}\n\n" if total > 1 else ""
        try:
            await message.answer(
                f"{header}{part}",
                parse_mode=ParseMode.MARKDOWN_V2 if "|" in part else None
            )
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–∞—Å—Ç–∏ {i}: {str(e)}")

# --------------------- –ó–∞–ø—É—Å–∫
if __name__ == "__main__":
    dp.startup.register(on_startup)  # –Ø–≤–Ω–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞

    print("=== –°—Ç–∞—Ä—Ç –±–æ—Ç–∞ ===")
    print(f"üîë –¢–æ–∫–µ–Ω –±–æ—Ç–∞: {'—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' if Config.BOT_TOKEN else '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç!'}")
    print(f"üìÅ –ü—É—Ç—å –∫ –±–∞–∑–∞–º: {Config.FAISS_ROOT}")

    try:
        asyncio.run(dp.start_polling(
            bot,
            skip_updates=True,
            allowed_updates=dp.resolve_used_update_types()
        ))
    except KeyboardInterrupt:
        print("\nüõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"\nüí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")